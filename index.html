<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Необычный Mario</title>
  <style>
    /* --- Сброс стилей и базовые настройки --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; }
    body { background: #87CEEB; font-family: sans-serif; position: relative; }
    canvas { background: transparent; display: block; margin: 0 auto; }
    #ui { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #fff; font-size: 18px; text-shadow: 1px 1px 2px #000; }
    .fade { transition: opacity 0.5s; }
    .hidden { opacity: 0; pointer-events: none; }
    /* --- Меню и оверлей --- */
    #menu { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; }
    #menu h1 { font-size: 48px; margin-bottom: 20px; }
    #menu button { padding: 10px 20px; font-size: 20px; margin: 5px; cursor: pointer; border: none; border-radius: 5px; }
    #menu button:hover { background: rgba(255,255,255,0.2); }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="960" height="540"></canvas>
  <div id="ui">Score: 0 | Lives: 3 | Level: 1</div>
  <div id="menu">
    <h1>Необычный Mario</h1>
    <button id="startBtn">Начать игру</button>
    <button id="instructionsBtn">Инструкции</button>
    <div id="instructions" class="hidden fade">
      <p>Стрелки — движение</p>
      <p>Пробел — прыжок</p>
      <p>Ctrl — бросок огненного шара (после бонуса)</p>
      <button id="backBtn">Назад</button>
    </div>
  </div>
  <script>
    // =========================================
    // == Необычный Mario Platformer (~500 строк)
    // =========================================

    // --- Константы ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const UI = document.getElementById('ui');
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const instrBtn = document.getElementById('instructionsBtn');
    const backBtn = document.getElementById('backBtn');
    const instructions = document.getElementById('instructions');

    const GRAVITY = 0.6;
    const FRICTION = 0.8;
    const TILE = 32;
    const ROWS = 17;
    const COLS = 30;

    const STATE = { MENU: 0, PLAY:1, PAUSE:2, OVER:3 };
    let gameState = STATE.MENU;

    let keys = {}, touches = {}, lastTouch = null;
    let score = 0, lives = 3, level = 1;
    let player, camera, levelData, enemies = [], coins = [], projectiles = [];
    let bgLayers = [], parallaxSpeeds = [];

    // --- Загрузка изображений ---
    const imageFiles = {
      'tiles': 'tiles.png',  // тайл-спрайт карта
      'mario': 'mario.png',  // спрайт игрока
      'goomba': 'goomba.png',// враг
      'fireball': 'fireball.png',
      'coins': 'coins.png',
      'bg1':'bg_layer1.png', 'bg2':'bg_layer2.png', 'bg3':'bg_layer3.png'
    };
    const images = {};

    function loadImages(callback) {
      let loaded = 0, total = Object.keys(imageFiles).length;
      for (let key in imageFiles) {
        images[key] = new Image();
        images[key].src = imageFiles[key];
        images[key].onload = () => {
          loaded++;
          if (loaded === total) callback();
        };
      }
    }

    // --- Классы игровых объектов ---
    class GameObject {
      constructor(x,y,w,h) {
        this.x = x; this.y = y;
        this.width = w; this.height = h;
      }
      draw() {/* override */}
      update() {/* override */}
    }

    class Player extends GameObject {
      constructor(x,y) {
        super(x,y,28,32);
        this.velX = 0; this.velY = 0;
        this.speed = 3; this.jumpForce = 12;
        this.jumping = false; this.direction = 1;
        this.fireCooldown = 0; this.hasFire = false;
      }
      update() {
        // Горизонтальное движение
        if (keys['ArrowLeft']||keys['a']) { this.velX = -this.speed; this.direction=-1; }
        if (keys['ArrowRight']||keys['d']){ this.velX = this.speed; this.direction=1; }
        // Прыжок
        if ((keys[' ']||keys['Spacebar']) && !this.jumping) {
          this.jumping = true;
          this.velY = -this.jumpForce;
          // звук прыжка (вставить) 
        }
        // Огонь
        if ((keys['Control']||keys['ControlLeft']) && this.hasFire && this.fireCooldown<=0) {
          projectiles.push(new Fireball(this.x + this.direction*10, this.y+10, this.direction));
          this.fireCooldown = 30; // кадров
        }
        this.fireCooldown = Math.max(0,this.fireCooldown-1);

        // Физика
        this.velX *= FRICTION;
        this.velY += GRAVITY;
        this.x += this.velX;
        this.y += this.velY;

        // Камера следит за игроком
        camera.x = this.x - canvas.width/2 + this.width/2;
        camera.y = this.y - canvas.height/2 + this.height/2;

        // Столкновения с миром
        this.handleCollisions();

        // Смерть при падении
        if (this.y > ROWS*TILE) {
          this.die();
        }
      }
      handleCollisions() {
        // Определяем границы тела
        let left = Math.floor(this.x/TILE);
        let right = Math.floor((this.x+this.width)/TILE);
        let top = Math.floor(this.y/TILE);
        let bottom = Math.floor((this.y+this.height)/TILE);
        for (let r=top; r<=bottom; r++) {
          for (let c=left; c<=right; c++) {
            let tile = levelData[r]?.[c];
            if (tile===1) {
              // Блок земли
              let tx = c*TILE, ty = r*TILE;
              if (this.x+this.width>tx && this.x<tx+TILE && this.y+this.height>ty && this.y<ty+TILE) {
                // снизу
                if (this.velY>0) { this.y = ty-this.height; this.velY=0; this.jumping=false; }
                // сверху
                else if (this.velY<0) { this.y = ty+TILE; this.velY=0; }
              }
            }
            if (tile===2) {
              // Монета
              coins = coins.filter(cn=>!(cn.row===r && cn.col===c));
              score+=10; updateUI(); levelData[r][c]=0;
            }
            if (tile===3) {
              // Гриб (ускорение)
              levelData[r][c]=0; player.speed=6;
            }
            if (tile===4) {
              // Огонь
              levelData[r][c]=0; player.hasFire=true;
            }
          }
        }
      }
      die() {
        lives--; updateUI();
        if (lives<0) gameOver();
        else resetLevel();
      }
      draw() {
        // Простая отрисовка прямоугольником или спрайт
        ctx.save();
        ctx.translate(this.x-camera.x, this.y-camera.y);
        ctx.scale(this.direction,1);
        ctx.drawImage(images['mario'], this.direction<0?32:0,0,28,32, this.direction<0?-28:0,0,28,32);
        ctx.restore();
      }
    }

    class Goomba extends GameObject {
      constructor(x,y) { super(x,y,28,28); this.velX=1; }
      update() {
        this.x += this.velX;
        // отскок от стен
        let r = Math.floor(this.y/TILE), c = Math.floor((this.x+this.width/2)/TILE);
        if (levelData[r]?.[c]===1) this.velX*=-1;
        // столкновение с игроком
        if (this.x+this.width>player.x && this.x<player.x+player.width && this.y+this.height>player.y && this.y<player.y+player.height) {
          if (player.velY>0) { // топим гомбу
            enemies = enemies.filter(e=>e!==this); score+=50; updateUI();
          } else player.die();
        }
      }
      draw() { ctx.drawImage(images['goomba'], this.x-camera.x, this.y-camera.y,28,28); }
    }

    class Fireball extends GameObject {
      constructor(x,y,dir) { super(x,y,16,16); this.dir=dir; this.life=60; }
      update() {
        this.x += this.dir*5; this.y += GRAVITY;
        this.life--; if (this.life<0) projectiles = projectiles.filter(p=>p!==this);
        // столкновение
        let r = Math.floor(this.y/TILE), c = Math.floor(this.x/TILE);
        if (levelData[r]?.[c]===1) projectiles=projectiles.filter(p=>p!==this);
      }
      draw() { ctx.drawImage(images['fireball'], this.x-camera.x, this.y-camera.y,16,16); }
    }

    class Coin {
      constructor(row,col) { this.row=row; this.col=col; }
      draw() {
        let x= this.col*TILE-camera.x+8;
        let y= this.row*TILE-camera.y+8;
        ctx.drawImage(images['coins'],0,0,16,16,x,y,16,16);
      }
    }

    // --- Камера ---
    class Camera { constructor() { this.x=0; this.y=0; } }

    // --- Загрузка уровней ---
    const levels = [
      {
        data: [ /* 17x30 чисел: 0-пусто,1-блок,2-монета,3-мушрум,4-огонь */
          [/* ... */],
          // заполнить данными или генерировать процедурно
        ],
        enemySpawns: [ {x:400,y:400}, /*...*/ ]
      },
      // можно добавить несколько уровней
    ];

    function loadLevel(idx) {
      let lvl = levels[idx-1];
      levelData = JSON.parse(JSON.stringify(lvl.data));
      enemies = lvl.enemySpawns.map(s=>new Goomba(s.x,s.y));
      coins = [];
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (levelData[r][c]===2) coins.push(new Coin(r,c));
      resetPlayer();
    }

    function resetLevel() {
      loadLevel(level);
    }

    // --- Параллакс задний фон ---
    function initParallax() {
      bgLayers = [images['bg1'],images['bg2'],images['bg3']];
      parallaxSpeeds = [0.2,0.5,1];
    }
    function drawParallax() {
      bgLayers.forEach((img,i)=>{
        let speed = parallaxSpeeds[i];
        let x = -camera.x*speed % canvas.width;
        ctx.drawImage(img,x,0,canvas.width,canvas.height);
        if (x<0) ctx.drawImage(img,x+canvas.width,0,canvas.width,canvas.height);
      });
    }

    // --- Обновление UI ---
    function updateUI() {
      UI.textContent = `Score: ${score} | Lives: ${lives} | Level: ${level}`;
    }

    // --- Главный цикл ---
    let lastTime=0;
    function gameLoop(ts) {
      requestAnimationFrame(gameLoop);
      if (gameState!==STATE.PLAY) return;
      if (ts-lastTime<1000/60) return;
      lastTime=ts;

      // Обновления
      player.update();
      enemies.forEach(e=>e.update());
      projectiles.forEach(p=>p.update());

      // Очистка
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Рисуем фон
      drawParallax();
      
      // Рисуем тайлы
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
        let t=levelData[r][c]; if (!t) continue;
        let sx= (t===1?0:(t===3?32: t===4?64: 0));
        let sy= (t===2?0: t===1?0: t===3?32: t===4?32:0);
        ctx.drawImage(images['tiles'], sx,sy,32,32, c*TILE-camera.x, r*TILE-camera.y,32,32);
      }

      // Draw collectibles
      coins.forEach(cn=>cn.draw());

      // Draw actors
      enemies.forEach(e=>e.draw());
      projectiles.forEach(p=>p.draw());
      player.draw();
    }

    // --- Состояния игры ---
    startBtn.addEventListener('click', ()=>{
      menu.classList.add('hidden'); gameState=STATE.PLAY; loadLevel(level);
    });
    instrBtn.addEventListener('click', ()=>{ instructions.classList.remove('hidden'); });
    backBtn.addEventListener('click', ()=>{ instructions.classList.add('hidden'); });

    function gameOver() {
      gameState=STATE.OVER; alert(`Game Over! Score: ${score}`); location.reload();
    }

    // --- Ввод ---
    document.addEventListener('keydown', e=> keys[e.key]=true);
    document.addEventListener('keyup', e=> keys[e.key]=false);
    canvas.addEventListener('touchstart', e=>{ lastTouch=e.touches[0]; });
    canvas.addEventListener('touchmove', e=>{
      let t=e.touches[0], dx=t.clientX-lastTouch.clientX, dy=t.clientY-lastTouch.clientY;
      if (Math.abs(dx)>Math.abs(dy)) { keys[dx>0?'ArrowRight':'ArrowLeft']=true; }
      else { keys[dy>0?'ArrowDown':'ArrowUp']=true; }
      lastTouch=t;
    });
    canvas.addEventListener('touchend', ()=>{ keys={}; });

    // --- Инициализация ---
    loadImages(()=>{ initParallax(); /* скрыть меню? */ });
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
